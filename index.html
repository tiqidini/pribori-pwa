<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#3a86ff"/>
    <title>Список Приладів (React)</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="img/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f4f8; 
            color: #1c3144; 
        }
        .modal-content-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        .modal-content-scrollable::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
        }
        .modal-content-scrollable::-webkit-scrollbar-track {
            background-color: #e2e8f0;
        }
        @keyframes fadeInScale {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .modal-animation {
            animation: fadeInScale 0.2s ease-out;
        }
        @keyframes slideInNotification {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideOutNotification {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }
        .notification-slide-in { animation: slideInNotification 0.3s ease-out forwards; }
        .notification-slide-out { animation: slideOutNotification 0.3s ease-out forwards; }

        .date-expired-bg { background-color: #fee2e2; border-color: #fecaca; color: #991b1b; }
        .date-warning-bg { background-color: #fef3c7; border-color: #fde68a; color: #92400e; }
        
        .timeline-expired { background-color: #ef4444; }
        .timeline-warning { background-color: #f59e0b; }
        .timeline-ok { background-color: #22c55e; }

        .device-image-fallback {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e5e7eb;
            color: #9ca3af;
            font-size: 2rem; 
            border-radius: 0.375rem;
        }
        .image-zoom-modal-content {
            max-width: 90vw;
            max-height: 90vh;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        // --- Database Utilities (db.js) ---
        const DB_NAME = 'priboriReactDB';
        const STORE_NAME = 'devices';
        const DB_VERSION = 1;
        let dbInstance = null;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (dbInstance) {
                    resolve(dbInstance);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => reject(`Database error: ${event.target.error}`);
                request.onsuccess = (event) => {
                    dbInstance = event.target.result;
                    dbInstance.onclose = () => { dbInstance = null; console.warn("Database connection closed."); };
                    resolve(dbInstance);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onblocked = () => {
                    console.warn("Database open request blocked.");
                    alert("Будь ласка, закрийте інші вкладки з цим додатком, щоб оновити базу даних.");
                };
            });
        }

        async function getAllDevicesDB() {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onerror = (event) => reject(`Error getting all devices: ${event.target.error}`);
                request.onsuccess = (event) => resolve(event.target.result || []);
            });
        }

        async function saveDeviceDB(device) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                if (!device || typeof device.id === 'undefined') {
                    return reject("Invalid device object: ID is missing.");
                }
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(device);
                request.onerror = (event) => reject(`Error saving device: ${event.target.error}`);
                request.onsuccess = () => resolve();
            });
        }

        async function deleteDeviceDB(deviceId) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                if (!deviceId) return reject("Invalid device ID.");
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(deviceId);
                request.onerror = (event) => reject(`Error deleting device: ${event.target.error}`);
                request.onsuccess = () => resolve();
            });
        }
        
        async function clearAllDevicesDB() {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.clear();
                request.onerror = (event) => reject(`Error clearing store: ${event.target.error}`);
                request.onsuccess = () => resolve();
            });
        }


        // --- Calculation Utilities (calculations.js) ---
        function formatDate(dateString) {
            if (!dateString) return '--.--.----';
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'Невірна дата';
                const day = String(date.getUTCDate()).padStart(2, '0');
                const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                const year = date.getUTCFullYear();
                return `${day}.${month}.${year}`;
            } catch (e) { return 'Помилка дати'; }
        }

        function calculateNextCheckDate(lastCheckDateStr, mpiYears) {
            if (!lastCheckDateStr || !mpiYears || isNaN(parseInt(mpiYears)) || mpiYears <= 0) return null;
            try {
                const lastCheckDate = new Date(lastCheckDateStr);
                if (isNaN(lastCheckDate.getTime())) return null;
                lastCheckDate.setUTCFullYear(lastCheckDate.getUTCFullYear() + parseInt(mpiYears));
                lastCheckDate.setUTCDate(lastCheckDate.getUTCDate() - 1); 
                return lastCheckDate.toISOString().split('T')[0]; 
            } catch (e) { return null; }
        }

        function getNextCheckDateStatus(nextCheckDateStr) {
            if (!nextCheckDateStr) return { text: 'Не вказано', className: 'text-gray-500', date: null, sortPriority: 0, isWarning: false, isExpired: false };
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);
            try {
                const nextCheckDate = new Date(nextCheckDateStr);
                 if (isNaN(nextCheckDate.getTime())) return { text: 'Невірна дата', className: 'text-red-700', date: null, sortPriority: 0, isWarning: false, isExpired: false };
                nextCheckDate.setUTCHours(0,0,0,0);
                const warningDate = new Date(nextCheckDate);
                warningDate.setUTCDate(warningDate.getUTCDate() - 30);
                const formattedDate = formatDate(nextCheckDateStr);
                if (nextCheckDate < today) {
                    return { text: formattedDate, className: 'date-expired-bg', date: nextCheckDate, sortPriority: 3, isWarning: false, isExpired: true };
                } else if (warningDate <= today) {
                    return { text: formattedDate, className: 'date-warning-bg', date: nextCheckDate, sortPriority: 2, isWarning: true, isExpired: false };
                } else {
                    return { text: formattedDate, className: 'text-gray-700', date: nextCheckDate, sortPriority: 1, isWarning: false, isExpired: false };
                }
            } catch (e) { 
                return { text: 'Помилка дати', className: 'text-red-700', date: null, sortPriority: 0, isWarning: false, isExpired: false }; 
            }
        }

        function getTimelineData(lastCheckDateStr, nextCheckDateStr, mpiYears) {
            const statusInfo = getNextCheckDateStatus(nextCheckDateStr);
            let timelineClassName = 'timeline-ok';
            if (statusInfo.isExpired) timelineClassName = 'timeline-expired';
            else if (statusInfo.isWarning) timelineClassName = 'timeline-warning';

            if (!lastCheckDateStr || !nextCheckDateStr || !mpiYears || mpiYears <= 0) {
                return { percent: 0, timelineClassName };
            }
            try {
                const lastCheckDate = new Date(lastCheckDateStr);
                const periodEndDate = new Date(nextCheckDateStr);
                periodEndDate.setUTCDate(periodEndDate.getUTCDate() + 1); 
                const today = new Date();
                today.setUTCHours(0, 0, 0, 0);
                lastCheckDate.setUTCHours(0, 0, 0, 0);
                periodEndDate.setUTCHours(0, 0, 0, 0);

                if (isNaN(lastCheckDate.getTime()) || isNaN(periodEndDate.getTime())) {
                    return { percent: 0, timelineClassName };
                }
                const totalDuration = periodEndDate.getTime() - lastCheckDate.getTime();
                const timeElapsed = today.getTime() - lastCheckDate.getTime();
                let percentElapsed = 0;
                if (totalDuration > 0) {
                    percentElapsed = (timeElapsed / totalDuration) * 100;
                    percentElapsed = Math.max(0, Math.min(100, percentElapsed));
                } else if (timeElapsed >= 0 && totalDuration <= 0) { 
                    percentElapsed = 100;
                }
                if (statusInfo.isExpired) {
                    percentElapsed = 100;
                }
                return { percent: Math.round(percentElapsed), timelineClassName };
            } catch (e) {
                console.error("Error in getTimelineData", e, {lastCheckDateStr, nextCheckDateStr, mpiYears});
                return { percent: 0, timelineClassName };
            }
        }

        // --- CSV Parser Utility (csvParser.js) ---
        async function parseCSV(csvText) {
            const lines = csvText.split(/\r?\n/);
            const devicesToImport = [];
            for (let i = 2; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const columns = line.split(',');
                if (columns.length < 9) continue; 
                const rm = columns[1]?.trim();
                const name = columns[2]?.trim();
                const type = columns[3]?.trim();
                const serial = columns[4]?.trim();
                const lastCheckDateStr = columns[5]?.trim();
                const mpiStr = columns[7]?.trim();
                const location = columns[8]?.trim();
                if (!rm || !name || !type || !serial) continue;
                let lastCheckDate = null;
                const dateMatch = lastCheckDateStr.match(/^(\d{2})\.(\d{2})\.(\d{4})$/);
                if (dateMatch) {
                    lastCheckDate = `${dateMatch[3]}-${dateMatch[2]}-${dateMatch[1]}`;
                }
                const mpi = parseInt(mpiStr) || null;
                devicesToImport.push({
                    rm, name, type, serial, lastCheckDate, mpi, location: location || null,
                    povirkyLocation: null, notes: null,
                });
            }
            return devicesToImport;
        }

        // --- React Components ---

        // Header Component
        function Header({ overdueCount }) {
            return (
                <header className="bg-gradient-to-r from-blue-600 to-blue-500 text-white p-4 shadow-md sticky top-0 z-50">
                    <div className="container mx-auto flex justify-between items-center max-w-6xl">
                        <h1 className="text-xl sm:text-2xl font-semibold">Список приладів</h1>
                        <div title="Кількість приладів з простроченою повіркою" className="flex items-center gap-2 bg-white/20 px-3 py-1.5 rounded-md text-sm font-medium">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" className="bi bi-exclamation-triangle-fill text-yellow-300" viewBox="0 0 16 16">
                                <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5m.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2"/>
                            </svg>
                            <span>{overdueCount}</span>
                        </div>
                    </div>
                </header>
            );
        }

        // FilterControls Component
        function FilterControls({ currentRM, onRMChange, onAddDevice, onExport, onImportTrigger, searchTerm, onSearchChange }) {
            const rms = ["all", "111", "112"];
            return (
                <div className="my-4 flex flex-col md:flex-row gap-4 items-center justify-between">
                    {/* Left side: RM Filter and Search - now in one row for medium screens and up */}
                    <div className="flex flex-col sm:flex-row items-center gap-4 w-full lg:w-auto">
                        <div className="flex items-center gap-2">
                            <span className="text-sm font-medium text-gray-600">РМ:</span>
                            <div className="inline-flex rounded-md shadow-sm bg-gray-200">
                                {rms.map(rm => (
                                    <button
                                        key={rm}
                                        onClick={() => onRMChange(rm)}
                                        className={`px-3 py-1.5 text-sm font-medium first:rounded-l-md last:rounded-r-md border border-gray-300 focus:z-10 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors
                                            ${currentRM === rm ? 'bg-blue-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}`}
                                    >
                                        {rm === "all" ? "Всі" : rm}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div className="relative flex-grow w-full sm:w-auto">
                            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <i className="fas fa-search text-gray-400"></i>
                            </div>
                            <input
                                type="text"
                                placeholder="Пошук за назвою, типом, S/N..."
                                value={searchTerm}
                                onChange={onSearchChange}
                                className="block w-full pl-10 pr-3 py-1.5 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                            />
                        </div>
                    </div>
                    {/* Right side: Action Buttons - now in one row for medium screens and up */}
                    <div className="flex items-center gap-2 flex-wrap justify-center md:justify-end mt-4 md:mt-0 w-full md:w-auto">
                        <button
                            onClick={onExport}
                            className="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md shadow-md hover:shadow-lg transition-all duration-150 ease-in-out flex items-center gap-2 text-sm"
                        >
                           <i className="fas fa-file-export"></i> Экспорт
                        </button>
                        <button
                            onClick={onImportTrigger}
                            className="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-3 rounded-md shadow-md hover:shadow-lg transition-all duration-150 ease-in-out flex items-center gap-2 text-sm"
                        >
                           <i className="fas fa-file-import"></i> Импорт
                        </button>
                        <button
                            onClick={onAddDevice}
                            className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:shadow-lg transition-all duration-150 ease-in-out flex items-center gap-2 text-sm"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" className="bi bi-plus-lg" viewBox="0 0 16 16">
                                <path fillRule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2"/>
                            </svg>
                            Додати
                        </button>
                    </div>
                </div>
            );
        }
        
        // ImageZoomModal Component
        function ImageZoomModal({ imageUrl, onClose }) {
            if (!imageUrl) return null;
            return (
                <div 
                    className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-[1050] modal-animation" 
                    onClick={onClose}
                >
                    <div 
                        className="bg-white p-2 rounded-lg shadow-2xl relative image-zoom-modal-content" 
                        onClick={e => e.stopPropagation()}
                    >
                        <img src={imageUrl} alt="Збільшене зображення приладу" className="max-w-full max-h-full object-contain rounded" />
                        <button 
                            onClick={onClose} 
                            className="absolute top-2 right-2 text-white bg-black bg-opacity-50 hover:bg-opacity-75 rounded-full p-1.5 leading-none"
                            aria-label="Закрити збільшене зображення"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            );
        }

        // DeviceCard Component
        function DeviceCard({ device, onEdit, onImageClick }) {
            const nextCheckStatus = getNextCheckDateStatus(calculateNextCheckDate(device.lastCheckDate, device.mpi));
            const timeline = getTimelineData(device.lastCheckDate, calculateNextCheckDate(device.lastCheckDate, device.mpi), device.mpi);
            // CORRECTED Regex: Only replace specified special characters, keep hyphens.
            const imageFileName = device.type ? `${device.type.replace(/[\/\s\\?%*:|"<>]/g, '_')}.png` : null;
            const imageUrl = imageFileName ? `img/${imageFileName}` : null;
            
            // console.log(`Device Type: ${device.type}, Attempting to load image: ${imageUrl}`); // Keep for debugging if needed

            const [imageError, setImageError] = useState(false);

            useEffect(() => {
                setImageError(false);
            }, [device.type]); // Reset error when device.type changes

            const handleImageClick = (e) => {
                e.stopPropagation();
                if (imageUrl && !imageError) {
                    onImageClick(imageUrl);
                }
            };

            return (
                <div
                    onClick={() => onEdit(device)}
                    className="bg-white rounded-lg shadow-lg hover:shadow-xl transition-shadow duration-200 p-4 cursor-pointer border border-gray-200 flex flex-col justify-between"
                >
                    <div className="flex-grow">
                        <div className="flex justify-between items-start gap-3">
                            <div className="flex-1 min-w-0">
                                <h3 className="text-md font-semibold text-blue-700 mb-1 truncate" title={device.name}>{device.name || 'Без назви'}</h3>
                                <p className="text-xs text-blue-500 font-medium mb-2 truncate" title={device.type}>{device.type || '-'}</p>
                                <div className="space-y-0.5 text-xs text-gray-600">
                                    <p><strong>Зав. №:</strong> {device.serial || '-'}</p>
                                    <p><strong>РМ:</strong> {device.rm || '-'}</p>
                                    <p><strong>Розташування:</strong> {device.location || '-'}</p>
                                    <p><strong>Місце повірки:</strong> {device.povirkyLocation || '-'}</p>
                                    <p><strong>Остання повірка:</strong> {formatDate(device.lastCheckDate)}</p>
                                    <p><strong>МПІ:</strong> {device.mpi ? `${device.mpi} р.` : '-'}</p>
                                    <p className="flex items-center"><strong>Наступна повірка:</strong>
                                        <span className={`ml-1 px-1.5 py-0.5 rounded-sm text-xs font-medium ${nextCheckStatus.className}`}>
                                            {nextCheckStatus.text}
                                        </span>
                                    </p>
                                </div>
                            </div>
                            {imageUrl && (
                                <div 
                                    className="w-16 h-16 sm:w-20 sm:h-20 flex-shrink-0 ml-2 cursor-pointer"
                                    onClick={handleImageClick}
                                >
                                    {!imageError ? (
                                        <img 
                                            src={imageUrl} 
                                            alt={`Зображення ${device.type}`} 
                                            className="w-full h-full object-contain rounded-md"
                                            onError={(e) => {
                                                // console.error(`Failed to load image for ${device.type}: ${imageUrl}`, e);
                                                setImageError(true);
                                            }} 
                                        />
                                    ) : (
                                        <div className="w-full h-full device-image-fallback">
                                            <i className="fas fa-image"></i>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="mt-3">
                        {(timeline.percent > 0 || timeline.timelineClassName === 'timeline-expired') && (
                            <div className="mb-2" title={`Пройшло приблизно ${timeline.percent}% інтервалу повірки`}>
                                <div className="w-full bg-gray-200 rounded-full h-2.5">
                                    <div
                                        className={`h-2.5 rounded-full ${timeline.timelineClassName} transition-all duration-500 ease-out flex items-center justify-center`}
                                        style={{ width: `${timeline.percent}%` }}
                                    ></div>
                                </div>
                            </div>
                        )}
                        {device.notes && <p className="text-xs text-gray-500 italic border-t border-gray-100 pt-1.5"><strong>Примітки:</strong> {device.notes}</p>}
                    </div>
                </div>
            );
        }

        // DeviceList Component
        function DeviceList({ devices, onEdit, onImageClick, isLoading }) {
            if (isLoading && devices.length === 0) { 
                return <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Завантаження приладів...</div>;
            }
            if (!isLoading && devices.length === 0) { 
                 return <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Список приладів порожній або не знайдено за фільтрами.</div>;
            }
            return (
                <>
                    <div className="text-sm text-gray-600 text-right mb-2">
                        Показано: {devices.length} прилад(ів)
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                        {devices.map(device => (
                            <DeviceCard key={device.id} device={device} onEdit={onEdit} onImageClick={onImageClick} />
                        ))}
                    </div>
                </>
            );
        }

        // DeviceModal Component
        function DeviceModal({ device, onClose, onSave, onDelete }) {
            const [formData, setFormData] = useState({
                id: '', rm: '', name: '', type: '', serial: '',
                lastCheckDate: '', mpi: '', location: '', povirkyLocation: '', notes: ''
            });
            useEffect(() => {
                if (device) {
                    setFormData({ ...device, mpi: device.mpi || '', lastCheckDate: device.lastCheckDate || '' });
                } else { 
                    setFormData({
                        id: '', rm: '', name: '', type: '', serial: '',
                        lastCheckDate: '', mpi: '', location: '', povirkyLocation: '', notes: ''
                    });
                }
            }, [device]);
            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            };
            const handleSubmit = (e) => {
                e.preventDefault();
                const deviceToSave = {
                    ...formData,
                    mpi: formData.mpi ? parseInt(formData.mpi) : null,
                    lastCheckDate: formData.lastCheckDate || null, 
                };
                if (!deviceToSave.rm || !deviceToSave.name || !deviceToSave.type || !deviceToSave.serial) {
                    alert("Будь ласка, заповніть обов'язкові поля: РМ, Найменування, Тип, Заводський номер.");
                    return;
                }
                onSave(deviceToSave);
            };
            const handleDelete = () => {
                if (device && device.id && window.confirm(`Ви впевнені, що хочете видалити "${device.name || 'цей прилад'}"?`)) {
                    onDelete(device.id);
                }
            };
            const inputClass = "mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm";
            const labelClass = "block text-sm font-medium text-gray-700";
            return (
                <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center p-4 z-[1000] modal-animation" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg max-h-[90vh] overflow-y-auto modal-content-scrollable" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-semibold text-gray-800">{device ? 'Редагувати Прилад' : 'Додати Прилад'}</h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                                </svg>
                            </button>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label htmlFor="device-rm" className={labelClass}>РМ: <span className="text-red-500">*</span></label>
                                <input type="text" name="rm" id="device-rm" value={formData.rm} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-name" className={labelClass}>Найменування: <span className="text-red-500">*</span></label>
                                <input type="text" name="name" id="device-name" value={formData.name} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-type" className={labelClass}>Тип: <span className="text-red-500">*</span></label>
                                <input type="text" name="type" id="device-type" value={formData.type} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-serial" className={labelClass}>Заводський номер: <span className="text-red-500">*</span></label>
                                <input type="text" name="serial" id="device-serial" value={formData.serial} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-lastCheckDate" className={labelClass}>Дата останньої повірки:</label>
                                <input type="date" name="lastCheckDate" id="device-lastCheckDate" value={formData.lastCheckDate} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-mpi" className={labelClass}>МПІ (роки):</label>
                                <input type="number" name="mpi" id="device-mpi" value={formData.mpi} onChange={handleChange} className={inputClass} min="1" />
                            </div>
                            <div>
                                <label htmlFor="device-location" className={labelClass}>Де прилад:</label>
                                <input type="text" name="location" id="device-location" value={formData.location} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-povirkyLocation" className={labelClass}>Місце повірки:</label>
                                <input type="text" name="povirkyLocation" id="device-povirkyLocation" value={formData.povirkyLocation} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-notes" className={labelClass}>Примітки:</label>
                                <textarea name="notes" id="device-notes" value={formData.notes} onChange={handleChange} rows="3" className={inputClass}></textarea>
                            </div>
                            <div className="flex justify-between items-center pt-4 border-t border-gray-200 mt-6">
                                <button type="submit" className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:shadow-md transition flex items-center gap-2">
                                    <i className="fas fa-save"></i> Зберегти
                                </button>
                                {device && (
                                    <button type="button" onClick={handleDelete} className="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:shadow-md transition flex items-center gap-2">
                                        <i className="fas fa-trash"></i> Видалити
                                    </button>
                                )}
                            </div>
                        </form>
                    </div>
                </div>
            );
        }
        
        // NotificationItem Component
        function NotificationItem({ notification, onClose }) {
            const [isVisible, setIsVisible] = useState(true);
            const handleClose = () => {
                setIsVisible(false);
                setTimeout(onClose, 300);
            };
            if (!notification.device) return null;
            const isWarning = notification.type === 'warning';
            const bgColor = isWarning ? 'bg-amber-50 border-amber-400' : 'bg-red-50 border-red-400';
            const iconColor = isWarning ? 'text-amber-500' : 'text-red-500';
            const titleColor = isWarning ? 'text-amber-800' : 'text-red-800';
            const textColor = isWarning ? 'text-amber-700' : 'text-red-700';
            const buttonHoverBg = isWarning ? 'hover:bg-amber-100' : 'hover:bg-red-100';
            const buttonFocusRing = isWarning ? 'focus:ring-amber-600 focus:ring-offset-amber-50' : 'focus:ring-red-600 focus:ring-offset-red-50';
            return (
                 <div className={`flex items-start p-3 mb-3 rounded-md shadow-lg border-l-4 ${bgColor} ${isVisible ? 'notification-slide-in' : 'notification-slide-out'}`}>
                    <div className="flex-shrink-0 pt-0.5">
                        <i className={`fas ${isWarning ? 'fa-triangle-exclamation' : 'fa-calendar-times'} ${iconColor} fa-lg`}></i>
                    </div>
                    <div className="ml-3 flex-1">
                        <p className={`text-sm font-medium ${titleColor}`}>
                            <strong>{notification.title}</strong>
                        </p>
                        <p className={`mt-1 text-xs ${textColor}`}>
                            Прилад типу "{notification.device.type || 'Невідомий тип'}" (РМ: {notification.device.rm || '?'})
                            потребує повірки в "{notification.device.povirkyLocation}". Наступна повірка: {notification.nextCheckDateText}.
                        </p>
                    </div>
                    <div className="ml-auto pl-3">
                        <div className="-mx-1.5 -my-1.5">
                            <button
                                type="button"
                                onClick={handleClose}
                                className={`inline-flex rounded-md p-1.5 ${iconColor} ${buttonHoverBg} focus:outline-none focus:ring-2 ${buttonFocusRing}`}
                            >
                                <span className="sr-only">Закрити</span>
                                <i className="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // NotificationsArea Component
        function NotificationsArea({ devices }) {
            const [notifications, setNotifications] = useState([]);
            useEffect(() => {
                const activeNotifications = devices
                    .map(device => {
                        const nextCheck = calculateNextCheckDate(device.lastCheckDate, device.mpi);
                        const status = getNextCheckDateStatus(nextCheck);
                        const hasValidPovirkyLocation = device.povirkyLocation && device.povirkyLocation.trim() !== '-' && device.povirkyLocation.trim() !== '';
                        if (status.isExpired && hasValidPovirkyLocation) {
                            return {
                                id: device.id + '-expired-notif', 
                                device,
                                title: 'Прострочена Повірка!',
                                nextCheckDateText: status.text,
                                type: 'expired', 
                                date: status.date
                            };
                        } else if (status.isWarning && hasValidPovirkyLocation) {
                             return {
                                id: device.id + '-warning-notif', 
                                device,
                                title: 'Незабаром Повірка!',
                                nextCheckDateText: status.text,
                                type: 'warning', 
                                date: status.date
                            };
                        }
                        return null;
                    })
                    .filter(Boolean)
                    .sort((a, b) => {
                        if (a.type === 'expired' && b.type !== 'expired') return -1;
                        if (a.type !== 'expired' && b.type === 'expired') return 1;
                        if (a.type === 'warning' && b.type !== 'warning') return -1;
                        if (a.type !== 'warning' && b.type === 'warning') return 1;
                        return (a.date && b.date) ? a.date.getTime() - b.date.getTime() : 0;
                    });
                setNotifications(activeNotifications);
            }, [devices]);
            const handleCloseNotification = (id) => {
                setNotifications(prev => prev.filter(n => n.id !== id));
            };
            if (notifications.length === 0) return null;
            return (
                <div className="my-4 space-y-3">
                    {notifications.map(notif => (
                        <NotificationItem key={notif.id} notification={notif} onClose={() => handleCloseNotification(notif.id)} />
                    ))}
                </div>
            );
        }

        // Main App Component
        function App() {
            const [allDevices, setAllDevices] = useState([]);
            const [currentRMFilter, setCurrentRMFilter] = useState('all');
            const [searchTerm, setSearchTerm] = useState('');
            const [editingDevice, setEditingDevice] = useState(null);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [isLoading, setIsLoading] = useState(true);
            const [zoomedImageUrl, setZoomedImageUrl] = useState(null);
            const fileInputRef = useRef(null);

            const loadDevices = useCallback(async () => {
                setIsLoading(true);
                try {
                    await initDB(); 
                    let currentDevs = await getAllDevicesDB();
                    if (currentDevs.length === 0) {
                        console.log("База даних порожня. Спроба імпорту з CSV...");
                        try {
                            const response = await fetch('Прилади - Аркуш1.csv');
                            if (!response.ok) throw new Error(`Не вдалося завантажити CSV: ${response.statusText}`);
                            const csvText = await response.text();
                            const parsedDevices = await parseCSV(csvText);
                            if (parsedDevices.length > 0) {
                                const savePromises = parsedDevices.map(devData => {
                                    const newId = (devData.serial || 'no_serial_csv') + '_' + Date.now() + '_' + Math.random().toString(16).slice(2,8);
                                    const deviceToSave = {
                                      ...devData,
                                      id: newId,
                                      nextCheckDate: calculateNextCheckDate(devData.lastCheckDate, devData.mpi) 
                                    };
                                    return saveDeviceDB(deviceToSave);
                                });
                                await Promise.all(savePromises);
                                console.log(`${parsedDevices.length} приладів імпортовано та збережено.`);
                                currentDevs = await getAllDevicesDB();
                            } else {
                                console.log("CSV файл порожній або не містить валідних даних.");
                            }
                        } catch (csvError) {
                            console.error("Помилка імпорту CSV:", csvError);
                        }
                    }
                    setAllDevices(currentDevs);
                } catch (error) {
                    console.error("Failed to load devices:", error);
                    alert("Помилка завантаження приладів. Перевірте консоль.");
                } finally {
                    setIsLoading(false);
                }
            }, []);

            useEffect(() => {
                loadDevices();
            }, [loadDevices]);

            const filteredAndSortedDevices = useMemo(() => {
                let devicesToDisplay = [...allDevices];
                if (currentRMFilter !== 'all') {
                    devicesToDisplay = devicesToDisplay.filter(device => device.rm === currentRMFilter);
                }
                if (searchTerm.trim() !== '') {
                    const lowerSearchTerm = searchTerm.toLowerCase();
                    devicesToDisplay = devicesToDisplay.filter(device => 
                        (device.name && device.name.toLowerCase().includes(lowerSearchTerm)) ||
                        (device.type && device.type.toLowerCase().includes(lowerSearchTerm)) ||
                        (device.serial && device.serial.toLowerCase().includes(lowerSearchTerm))
                    );
                }
                return devicesToDisplay.sort((a, b) => {
                    const statusA = getNextCheckDateStatus(calculateNextCheckDate(a.lastCheckDate, a.mpi));
                    const statusB = getNextCheckDateStatus(calculateNextCheckDate(b.lastCheckDate, b.mpi));
                    if (statusB.sortPriority !== statusA.sortPriority) {
                        return statusB.sortPriority - statusA.sortPriority;
                    }
                    const dateA = statusA.date;
                    const dateB = statusB.date;
                    if (dateA && dateB) return dateA.getTime() - dateB.getTime();
                    if (dateA) return -1;
                    if (dateB) return 1;
                    return 0;
                });
            }, [allDevices, currentRMFilter, searchTerm]);

            const handleRMFILTERChange = (rm) => setCurrentRMFilter(rm);
            const handleSearchChange = (event) => setSearchTerm(event.target.value);
            const handleAddDevice = () => {
                setEditingDevice(null);
                setIsModalOpen(true);
            };
            const handleEditDevice = (device) => {
                setEditingDevice(device);
                setIsModalOpen(true);
            };
            const handleCloseModal = () => {
                setIsModalOpen(false);
                setEditingDevice(null);
            };

            const handleSaveDevice = async (deviceData) => {
                try {
                    let deviceToSave;
                    if (deviceData.id) {
                        deviceToSave = { ...deviceData };
                    } else { 
                        const newId = (deviceData.serial || 'no_serial_new') + '_' + Date.now() + '_' + Math.random().toString(16).slice(2,8);
                        deviceToSave = { ...deviceData, id: newId };
                    }
                    deviceToSave.nextCheckDate = calculateNextCheckDate(deviceToSave.lastCheckDate, deviceToSave.mpi);
                    await saveDeviceDB(deviceToSave);
                    await loadDevices(); 
                    handleCloseModal();
                } catch (error) {
                    console.error("Failed to save device:", error);
                    alert("Помилка збереження приладу. Перевірте консоль.");
                }
            };

            const handleDeleteDevice = async (deviceId) => {
                try {
                    await deleteDeviceDB(deviceId);
                    await loadDevices(); 
                    handleCloseModal(); 
                } catch (error) {
                    console.error("Failed to delete device:", error);
                    alert("Помилка видалення приладу. Перевірте консоль.");
                }
            };

            const overdueCount = useMemo(() => {
                return allDevices.filter(device => {
                    const nextCheck = calculateNextCheckDate(device.lastCheckDate, device.mpi);
                    const status = getNextCheckDateStatus(nextCheck);
                    return status.isExpired;
                }).length;
            }, [allDevices]);

            useEffect(() => {
                if ('setAppBadge' in navigator) {
                    if (overdueCount > 0) {
                        navigator.setAppBadge(overdueCount).catch(error => {
                            console.error("Error setting app badge:", error);
                        });
                    } else {
                        navigator.clearAppBadge().catch(error => {
                            console.error("Error clearing app badge:", error);
                        });
                    }
                }
            }, [overdueCount]);

            const handleImageZoom = (imageUrl) => {
                setZoomedImageUrl(imageUrl);
            };
            const handleCloseImageZoom = () => {
                setZoomedImageUrl(null);
            };

            const handleExportData = async () => {
                try {
                    const devicesToExport = await getAllDevicesDB();
                    if (devicesToExport.length === 0) {
                        alert("Немає даних для експорту.");
                        return;
                    }
                    const jsonData = JSON.stringify(devicesToExport, null, 2);
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'devices_data.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    alert("Дані успішно експортовано!");
                } catch (error) {
                    console.error("Error exporting data:", error);
                    alert("Помилка експорту даних.");
                }
            };

            const handleImportData = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }
                if (!window.confirm("УВАГА! Імпорт замінить усі поточні дані. Ви впевнені, що хочете продовжити?")) {
                    if(fileInputRef.current) fileInputRef.current.value = "";
                    return;
                }
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const importedDevices = JSON.parse(e.target.result);
                        if (!Array.isArray(importedDevices)) {
                            throw new Error("Формат файлу невірний. Очікується масив приладів.");
                        }
                        for(const device of importedDevices){
                            if(typeof device.id === 'undefined' || !device.name || !device.type || !device.serial){
                                throw new Error(`Невірний формат об'єкта приладу в файлі: ${JSON.stringify(device)}`);
                            }
                            device.nextCheckDate = calculateNextCheckDate(device.lastCheckDate, device.mpi);
                        }
                        await clearAllDevicesDB();
                        for (const device of importedDevices) {
                            await saveDeviceDB(device);
                        }
                        await loadDevices();
                        alert(`Дані успішно імпортовано. Завантажено ${importedDevices.length} прилад(ів).`);
                    } catch (error) {
                        console.error("Error importing data:", error);
                        alert(`Помилка імпорту даних: ${error.message}`);
                    } finally {
                         if(fileInputRef.current) fileInputRef.current.value = "";
                    }
                };
                reader.readAsText(file);
            };
            
            const triggerImportFileSelect = () => {
                if (fileInputRef.current) {
                    fileInputRef.current.click();
                }
            };

            return (
                <div className="min-h-screen bg-gray-100">
                    <Header overdueCount={overdueCount} />
                    <main className="container mx-auto p-4 max-w-6xl">
                        <FilterControls
                            currentRM={currentRMFilter}
                            onRMChange={handleRMFILTERChange}
                            searchTerm={searchTerm}
                            onSearchChange={handleSearchChange}
                            onAddDevice={handleAddDevice}
                            onExport={handleExportData}
                            onImportTrigger={triggerImportFileSelect}
                        />
                        <input 
                            type="file" 
                            accept=".json" 
                            ref={fileInputRef} 
                            onChange={handleImportData} 
                            className="hidden" 
                        />
                        <NotificationsArea devices={allDevices} />
                        <DeviceList
                            devices={filteredAndSortedDevices}
                            onEdit={handleEditDevice}
                            onImageClick={handleImageZoom}
                            isLoading={isLoading} 
                        />
                    </main>
                    {isModalOpen && (
                        <DeviceModal
                            device={editingDevice}
                            onClose={handleCloseModal}
                            onSave={handleSaveDevice}
                            onDelete={handleDeleteDevice}
                        />
                    )}
                    {zoomedImageUrl && (
                        <ImageZoomModal 
                            imageUrl={zoomedImageUrl} 
                            onClose={handleCloseImageZoom} 
                        />
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

        if ('serviceWorker' in navigator) {
            const swPath = 'service-worker.js'; 
            const swScope = './'; 
            navigator.serviceWorker.register(swPath, { scope: swScope })
            .then(registration => {
                registration.onupdatefound = () => {
                    const installingWorker = registration.installing;
                    if (installingWorker) {
                        installingWorker.onstatechange = () => {
                            if (installingWorker.state === 'installed') {
                                if (navigator.serviceWorker.controller) {
                                    console.log('Новий Service Worker встановлено. Оновіть сторінку для застосування.');
                                } else {
                                    console.log('Контент кешовано для офлайн використання.');
                                }
                            }
                        };
                    }
                };
            })
            .catch(error => {
                console.error('Помилка реєстрації Service Worker:', error);
            });
        } else {
             console.log('Service Worker не підтримується цим браузером.');
        }
    </script>
</body>
</html>
