<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#3a86ff"/>
    <title>Список Приладів (React)</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="img/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f4f8; /* Светло-серый фон */
            color: #1c3144; /* Темно-синий текст */
        }
        /* Custom scrollbar for modal content if needed */
        .modal-content-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        .modal-content-scrollable::-webkit-scrollbar-thumb {
            background-color: #cbd5e1; /* Tailwind gray-300 */
            border-radius: 4px;
        }
        .modal-content-scrollable::-webkit-scrollbar-track {
            background-color: #e2e8f0; /* Tailwind gray-200 */
        }
        /* Simple animation for modal */
        @keyframes fadeInScale {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .modal-animation {
            animation: fadeInScale 0.2s ease-out;
        }
         /* Notification animation */
        @keyframes slideInNotification {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideOutNotification {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }
        .notification-slide-in { animation: slideInNotification 0.3s ease-out forwards; }
        .notification-slide-out { animation: slideOutNotification 0.3s ease-out forwards; }

        /* Date status background colors */
        .date-expired-bg { background-color: #fee2e2; border-color: #fecaca; color: #991b1b; } /* Tailwind red-100, red-200, red-800 */
        .date-warning-bg { background-color: #fef3c7; border-color: #fde68a; color: #92400e; } /* Tailwind amber-100, amber-200, amber-800 */
        
        /* Timeline colors */
        .timeline-expired { background-color: #ef4444; } /* Tailwind red-500 */
        .timeline-warning { background-color: #f59e0b; } /* Tailwind amber-500 */
        .timeline-ok { background-color: #22c55e; } /* Tailwind green-500 */

        /* Fallback for image */
        .device-image-fallback {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e5e7eb; /* Tailwind gray-200 */
            color: #9ca3af; /* Tailwind gray-400 */
            font-size: 2rem; /* Larger icon */
            border-radius: 0.375rem; /* rounded-md */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;

        // --- Database Utilities (db.js) ---
        const DB_NAME = 'priboriReactDB';
        const STORE_NAME = 'devices';
        const DB_VERSION = 1;
        let dbInstance = null;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (dbInstance) {
                    resolve(dbInstance);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => reject(`Database error: ${event.target.error}`);
                request.onsuccess = (event) => {
                    dbInstance = event.target.result;
                    dbInstance.onclose = () => { dbInstance = null; console.warn("Database connection closed."); };
                    resolve(dbInstance);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onblocked = () => {
                    console.warn("Database open request blocked.");
                    alert("Будь ласка, закрийте інші вкладки з цим додатком, щоб оновити базу даних.");
                };
            });
        }

        async function getAllDevicesDB() {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onerror = (event) => reject(`Error getting all devices: ${event.target.error}`);
                request.onsuccess = (event) => resolve(event.target.result || []);
            });
        }

        async function saveDeviceDB(device) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                if (!device || typeof device.id === 'undefined') {
                    return reject("Invalid device object: ID is missing.");
                }
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(device);
                request.onerror = (event) => reject(`Error saving device: ${event.target.error}`);
                request.onsuccess = () => resolve();
            });
        }

        async function deleteDeviceDB(deviceId) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                if (!deviceId) return reject("Invalid device ID.");
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(deviceId);
                request.onerror = (event) => reject(`Error deleting device: ${event.target.error}`);
                request.onsuccess = () => resolve();
            });
        }

        // --- Calculation Utilities (calculations.js) ---
        function formatDate(dateString) {
            if (!dateString) return '--.--.----';
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'Невірна дата';
                // Используем UTC методы для избежания проблем с часовыми поясами при форматировании
                const day = String(date.getUTCDate()).padStart(2, '0');
                const month = String(date.getUTCMonth() + 1).padStart(2, '0'); // Месяцы 0-индексированные
                const year = date.getUTCFullYear();
                return `${day}.${month}.${year}`;
            } catch (e) { return 'Помилка дати'; }
        }

        function calculateNextCheckDate(lastCheckDateStr, mpiYears) {
            if (!lastCheckDateStr || !mpiYears || isNaN(parseInt(mpiYears)) || mpiYears <= 0) return null;
            try {
                const lastCheckDate = new Date(lastCheckDateStr);
                if (isNaN(lastCheckDate.getTime())) return null;
                // Используем UTC методы для корректных расчетов дат
                lastCheckDate.setUTCFullYear(lastCheckDate.getUTCFullYear() + parseInt(mpiYears));
                lastCheckDate.setUTCDate(lastCheckDate.getUTCDate() - 1); // За день до годовщины
                return lastCheckDate.toISOString().split('T')[0]; // Возвращаем YYYY-MM-DD
            } catch (e) { return null; }
        }

        function getNextCheckDateStatus(nextCheckDateStr) {
            if (!nextCheckDateStr) return { text: 'Не вказано', className: 'text-gray-500', date: null, sortPriority: 0, isWarning: false, isExpired: false };
            
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0); // Нормализуем сегодня до начала дня в UTC

            try {
                const nextCheckDate = new Date(nextCheckDateStr);
                 if (isNaN(nextCheckDate.getTime())) return { text: 'Невірна дата', className: 'text-red-700', date: null, sortPriority: 0, isWarning: false, isExpired: false };
                nextCheckDate.setUTCHours(0,0,0,0); // Нормализуем дату поверки до начала дня в UTC

                const warningDate = new Date(nextCheckDate);
                warningDate.setUTCDate(warningDate.getUTCDate() - 30); // За 30 дней до даты поверки
                
                const formattedDate = formatDate(nextCheckDateStr);

                if (nextCheckDate < today) {
                    return { text: formattedDate, className: 'date-expired-bg', date: nextCheckDate, sortPriority: 3, isWarning: false, isExpired: true };
                } else if (warningDate <= today) { // Если сегодня ПОСЛЕ или В ДЕНЬ начала 30-дневного окна
                    return { text: formattedDate, className: 'date-warning-bg', date: nextCheckDate, sortPriority: 2, isWarning: true, isExpired: false };
                } else {
                    return { text: formattedDate, className: 'text-gray-700', date: nextCheckDate, sortPriority: 1, isWarning: false, isExpired: false };
                }
            } catch (e) { 
                return { text: 'Помилка дати', className: 'text-red-700', date: null, sortPriority: 0, isWarning: false, isExpired: false }; 
            }
        }

        function getTimelineData(lastCheckDateStr, nextCheckDateStr, mpiYears) {
            const statusInfo = getNextCheckDateStatus(nextCheckDateStr);
            let timelineClassName = 'timeline-ok'; // Tailwind green-500
            if (statusInfo.isExpired) timelineClassName = 'timeline-expired'; // Tailwind red-500
            else if (statusInfo.isWarning) timelineClassName = 'timeline-warning'; // Tailwind amber-500

            if (!lastCheckDateStr || !nextCheckDateStr || !mpiYears || mpiYears <= 0) {
                return { percent: 0, timelineClassName };
            }
            try {
                const lastCheckDate = new Date(lastCheckDateStr);
                // nextCheckDateStr это уже дата "за день до годовщины"
                // Для расчета общего интервала нам нужна фактическая дата окончания периода
                const periodEndDate = new Date(nextCheckDateStr);
                periodEndDate.setUTCDate(periodEndDate.getUTCDate() + 1); // Добавляем 1 день, чтобы получить годовщину

                const today = new Date();
                
                // Нормализация всех дат до UTC 00:00:00 для корректного сравнения и расчетов разниц
                today.setUTCHours(0, 0, 0, 0);
                lastCheckDate.setUTCHours(0, 0, 0, 0);
                periodEndDate.setUTCHours(0, 0, 0, 0);


                if (isNaN(lastCheckDate.getTime()) || isNaN(periodEndDate.getTime())) {
                     console.warn("Invalid dates for timeline:", lastCheckDateStr, nextCheckDateStr);
                    return { percent: 0, timelineClassName };
                }
                
                // Общая длительность интервала поверки в миллисекундах
                const totalDuration = periodEndDate.getTime() - lastCheckDate.getTime();
                // Время, прошедшее с последней поверки до сегодня
                const timeElapsed = today.getTime() - lastCheckDate.getTime();
                
                let percentElapsed = 0;
                if (totalDuration > 0) {
                    percentElapsed = (timeElapsed / totalDuration) * 100;
                    percentElapsed = Math.max(0, Math.min(100, percentElapsed)); // Ограничиваем 0-100%
                } else if (timeElapsed >= 0 && totalDuration <= 0) { 
                    // Если totalDuration <= 0 (например, lastCheckDate = periodEndDate или позже),
                    // и сегодня после lastCheckDate, то считаем 100%
                    percentElapsed = 100;
                }
                
                // Если просрочено, всегда 100%
                if (statusInfo.isExpired) {
                    percentElapsed = 100;
                }

                return { percent: Math.round(percentElapsed), timelineClassName };
            } catch (e) {
                console.error("Error in getTimelineData", e, {lastCheckDateStr, nextCheckDateStr, mpiYears});
                return { percent: 0, timelineClassName };
            }
        }


        // --- CSV Parser Utility (csvParser.js) ---
        async function parseCSV(csvText) {
            const lines = csvText.split(/\r?\n/);
            const devicesToImport = [];
            for (let i = 2; i < lines.length; i++) { // Начинаем с 3-й строки (индекс 2)
                const line = lines[i].trim();
                if (!line) continue;

                const columns = line.split(','); // Простой парсер
                if (columns.length < 9) continue; 

                const rm = columns[1]?.trim();
                const name = columns[2]?.trim();
                const type = columns[3]?.trim();
                const serial = columns[4]?.trim();
                const lastCheckDateStr = columns[5]?.trim();
                const mpiStr = columns[7]?.trim();
                const location = columns[8]?.trim();

                if (!rm || !name || !type || !serial) continue; // Пропускаем, если нет обязательных полей

                let lastCheckDate = null;
                const dateMatch = lastCheckDateStr.match(/^(\d{2})\.(\d{2})\.(\d{4})$/);
                if (dateMatch) {
                    lastCheckDate = `${dateMatch[3]}-${dateMatch[2]}-${dateMatch[1]}`; // YYYY-MM-DD
                }
                const mpi = parseInt(mpiStr) || null;

                devicesToImport.push({
                    rm, name, type, serial, lastCheckDate, mpi, location: location || null,
                    povirkyLocation: null, notes: null, // ID будет сгенерирован позже
                });
            }
            return devicesToImport;
        }


        // --- React Components ---

        // Header Component
        function Header({ overdueCount }) {
            return (
                <header className="bg-gradient-to-r from-blue-600 to-blue-500 text-white p-4 shadow-md sticky top-0 z-50">
                    <div className="container mx-auto flex justify-between items-center max-w-6xl">
                        <h1 className="text-xl sm:text-2xl font-semibold">Список приладів</h1>
                        <div title="Кількість приладів з простроченою повіркою" className="flex items-center gap-2 bg-white/20 px-3 py-1.5 rounded-md text-sm font-medium">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" className="bi bi-exclamation-triangle-fill text-yellow-300" viewBox="0 0 16 16">
                                <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5m.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2"/>
                            </svg>
                            <span>{overdueCount}</span>
                        </div>
                    </div>
                </header>
            );
        }

        // FilterControls Component
        function FilterControls({ currentRM, onRMChange, onAddDevice }) {
            const rms = ["all", "111", "112"]; // Пример РМ
            return (
                <div className="my-4 flex flex-wrap gap-4 items-center justify-between">
                    <div className="flex items-center gap-2">
                        <span className="text-sm font-medium text-gray-600">РМ:</span>
                        <div className="inline-flex rounded-md shadow-sm bg-gray-200">
                            {rms.map(rm => (
                                <button
                                    key={rm}
                                    onClick={() => onRMChange(rm)}
                                    className={`px-3 py-1.5 text-sm font-medium first:rounded-l-md last:rounded-r-md border border-gray-300 focus:z-10 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors
                                        ${currentRM === rm ? 'bg-blue-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}`}
                                >
                                    {rm === "all" ? "Всі" : rm}
                                </button>
                            ))}
                        </div>
                    </div>
                    <button
                        onClick={onAddDevice}
                        className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:shadow-lg transition-all duration-150 ease-in-out flex items-center gap-2 text-sm"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" className="bi bi-plus-lg" viewBox="0 0 16 16">
                            <path fillRule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2"/>
                        </svg>
                        Додати
                    </button>
                </div>
            );
        }

        // DeviceCard Component
        function DeviceCard({ device, onEdit }) {
            const nextCheckStatus = getNextCheckDateStatus(calculateNextCheckDate(device.lastCheckDate, device.mpi));
            const timeline = getTimelineData(device.lastCheckDate, calculateNextCheckDate(device.lastCheckDate, device.mpi), device.mpi);
            
            // Формируем путь к изображению
            // Заменяем спецсимволы в типе прибора на подчеркивание для имени файла
            const imageFileName = device.type ? `${device.type.replace(/[\/\s\\?%*:|"<>]/g, '_')}.png` : null;
            const imageUrl = imageFileName ? `img/${imageFileName}` : null;

            const [imageError, setImageError] = useState(false);

            useEffect(() => {
                setImageError(false); // Сбрасываем ошибку при смене device.type
            }, [device.type]);

            return (
                <div
                    onClick={() => onEdit(device)}
                    className="bg-white rounded-lg shadow-lg hover:shadow-xl transition-shadow duration-200 p-4 cursor-pointer border border-gray-200 flex flex-col justify-between"
                >
                    <div className="flex-grow">
                        <div className="flex justify-between items-start gap-3">
                            <div className="flex-1 min-w-0"> {/* Контейнер для текста, чтобы он мог сжиматься */}
                                <h3 className="text-md font-semibold text-blue-700 mb-1 truncate" title={device.name}>{device.name || 'Без назви'}</h3>
                                <p className="text-xs text-blue-500 font-medium mb-2 truncate" title={device.type}>{device.type || '-'}</p>
                                <div className="space-y-0.5 text-xs text-gray-600"> {/* Уменьшен space-y */}
                                    <p><strong>Зав. №:</strong> {device.serial || '-'}</p>
                                    <p><strong>РМ:</strong> {device.rm || '-'}</p>
                                    <p><strong>Розташування:</strong> {device.location || '-'}</p>
                                    <p><strong>Місце повірки:</strong> {device.povirkyLocation || '-'}</p>
                                    <p><strong>Остання пов.:</strong> {formatDate(device.lastCheckDate)}</p>
                                    <p><strong>МПІ:</strong> {device.mpi ? `${device.mpi} р.` : '-'}</p>
                                    <p className="flex items-center"><strong>Наступна пов.:</strong>
                                        <span className={`ml-1 px-1.5 py-0.5 rounded-sm text-xs font-medium ${nextCheckStatus.className}`}>
                                            {nextCheckStatus.text}
                                        </span>
                                    </p>
                                </div>
                            </div>
                            {imageUrl && !imageError && (
                                <div className="w-16 h-16 sm:w-20 sm:h-20 flex-shrink-0 ml-2">
                                    <img 
                                        src={imageUrl} 
                                        alt={`Зображення ${device.type}`} 
                                        className="w-full h-full object-contain rounded-md"
                                        onError={() => setImageError(true)} 
                                    />
                                </div>
                            )}
                             {imageError && imageUrl && ( // Показываем fallback, если была ошибка и imageUrl был
                                <div className="w-16 h-16 sm:w-20 sm:h-20 flex-shrink-0 ml-2 device-image-fallback">
                                    <i className="fas fa-image"></i>
                                </div>
                            )}
                        </div>
                    </div>

                    <div className="mt-3"> {/* Контейнер для шкалы и примечаний */}
                        {(timeline.percent > 0 || timeline.timelineClassName === 'timeline-expired') && (
                            <div className="mb-2" title={`Пройшло приблизно ${timeline.percent}% інтервалу повірки`}>
                                <div className="w-full bg-gray-200 rounded-full h-2.5"> {/* Немного толще шкала */}
                                    <div
                                        className={`h-2.5 rounded-full ${timeline.timelineClassName} transition-all duration-500 ease-out flex items-center justify-center`}
                                        style={{ width: `${timeline.percent}%` }}
                                    >
                                      {/* Можно добавить текст внутрь шкалы, если она достаточно широкая */}
                                      {/* <span className="text-xs font-medium text-white">{timeline.percent}%</span> */}
                                    </div>
                                </div>
                            </div>
                        )}
                        {device.notes && <p className="text-xs text-gray-500 italic border-t border-gray-100 pt-1.5"><strong>Примітки:</strong> {device.notes}</p>}
                    </div>
                </div>
            );
        }

        // DeviceList Component
        function DeviceList({ devices, onEdit, currentRMFilter }) {
             const filteredDevices = useMemo(() => {
                const filtered = currentRMFilter === 'all'
                    ? [...devices]
                    : devices.filter(device => device.rm === currentRMFilter);

                // Сортировка: сначала просроченные, потом предупреждения, потом остальные, по дате
                return filtered.sort((a, b) => {
                    const statusA = getNextCheckDateStatus(calculateNextCheckDate(a.lastCheckDate, a.mpi));
                    const statusB = getNextCheckDateStatus(calculateNextCheckDate(b.lastCheckDate, b.mpi));

                    if (statusB.sortPriority !== statusA.sortPriority) {
                        return statusB.sortPriority - statusA.sortPriority; // Сначала с большим приоритетом
                    }
                    // Если приоритеты равны, сортируем по дате (раньшие даты сначала)
                    const dateA = statusA.date;
                    const dateB = statusB.date;
                    if (dateA && dateB) return dateA.getTime() - dateB.getTime();
                    if (dateA) return -1; // A имеет дату, B нет - A выше
                    if (dateB) return 1;  // B имеет дату, A нет - B выше
                    return 0; // Дат нет или равны
                });
            }, [devices, currentRMFilter]);


            if (devices.length === 0) {
                return <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Завантаження приладів або список порожній...</div>;
            }
            if (filteredDevices.length === 0 && currentRMFilter !== 'all') {
                 return <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Немає приладів для РМ "{currentRMFilter}".</div>;
            }


            return (
                <>
                    <div className="text-sm text-gray-600 text-right mb-2">
                        Показано: {filteredDevices.length} прилад(ів)
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                        {filteredDevices.map(device => (
                            <DeviceCard key={device.id} device={device} onEdit={onEdit} />
                        ))}
                    </div>
                </>
            );
        }

        // DeviceModal Component
        function DeviceModal({ device, onClose, onSave, onDelete }) {
            const [formData, setFormData] = useState({
                id: '', rm: '', name: '', type: '', serial: '',
                lastCheckDate: '', mpi: '', location: '', povirkyLocation: '', notes: ''
            });

            useEffect(() => {
                if (device) {
                    setFormData({ ...device, mpi: device.mpi || '', lastCheckDate: device.lastCheckDate || '' });
                } else { // Сброс формы для нового прибора
                    setFormData({
                        id: '', rm: '', name: '', type: '', serial: '',
                        lastCheckDate: '', mpi: '', location: '', povirkyLocation: '', notes: ''
                    });
                }
            }, [device]);

            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                const deviceToSave = {
                    ...formData,
                    mpi: formData.mpi ? parseInt(formData.mpi) : null,
                    lastCheckDate: formData.lastCheckDate || null, // Убедимся, что пустая дата это null
                };
                // Простая валидация обязательных полей
                if (!deviceToSave.rm || !deviceToSave.name || !deviceToSave.type || !deviceToSave.serial) {
                    alert("Будь ласка, заповніть обов'язкові поля: РМ, Найменування, Тип, Заводський номер.");
                    return;
                }
                onSave(deviceToSave);
            };

            const handleDelete = () => {
                if (device && device.id && window.confirm(`Ви впевнені, що хочете видалити "${device.name || 'цей прилад'}"?`)) {
                    onDelete(device.id);
                }
            };
            
            const inputClass = "mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm";
            const labelClass = "block text-sm font-medium text-gray-700";

            return (
                <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center p-4 z-[1000] modal-animation" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg max-h-[90vh] overflow-y-auto modal-content-scrollable" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-semibold text-gray-800">{device ? 'Редагувати Прилад' : 'Додати Прилад'}</h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                                </svg>
                            </button>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label htmlFor="device-rm" className={labelClass}>РМ: <span className="text-red-500">*</span></label>
                                <input type="text" name="rm" id="device-rm" value={formData.rm} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-name" className={labelClass}>Найменування: <span className="text-red-500">*</span></label>
                                <input type="text" name="name" id="device-name" value={formData.name} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-type" className={labelClass}>Тип: <span className="text-red-500">*</span></label>
                                <input type="text" name="type" id="device-type" value={formData.type} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-serial" className={labelClass}>Заводський номер: <span className="text-red-500">*</span></label>
                                <input type="text" name="serial" id="device-serial" value={formData.serial} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-lastCheckDate" className={labelClass}>Дата останньої повірки:</label>
                                <input type="date" name="lastCheckDate" id="device-lastCheckDate" value={formData.lastCheckDate} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-mpi" className={labelClass}>МПІ (роки):</label>
                                <input type="number" name="mpi" id="device-mpi" value={formData.mpi} onChange={handleChange} className={inputClass} min="1" />
                            </div>
                            <div>
                                <label htmlFor="device-location" className={labelClass}>Де прилад:</label>
                                <input type="text" name="location" id="device-location" value={formData.location} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-povirkyLocation" className={labelClass}>Місце повірки:</label>
                                <input type="text" name="povirkyLocation" id="device-povirkyLocation" value={formData.povirkyLocation} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-notes" className={labelClass}>Примітки:</label>
                                <textarea name="notes" id="device-notes" value={formData.notes} onChange={handleChange} rows="3" className={inputClass}></textarea>
                            </div>
                            <div className="flex justify-between items-center pt-4 border-t border-gray-200 mt-6">
                                <button type="submit" className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:shadow-md transition flex items-center gap-2">
                                    <i className="fas fa-save"></i> Зберегти
                                </button>
                                {device && (
                                    <button type="button" onClick={handleDelete} className="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:shadow-md transition flex items-center gap-2">
                                        <i className="fas fa-trash"></i> Видалити
                                    </button>
                                )}
                            </div>
                        </form>
                    </div>
                </div>
            );
        }
        
        // NotificationItem Component
        function NotificationItem({ notification, onClose }) {
            const [isVisible, setIsVisible] = useState(true);

            const handleClose = () => {
                setIsVisible(false);
                setTimeout(onClose, 300); // Удаляем после анимации
            };
            
            if (!notification.device) return null; // Защита

            const isWarning = notification.type === 'warning';
            const bgColor = isWarning ? 'bg-amber-50 border-amber-400' : 'bg-red-50 border-red-400';
            const iconColor = isWarning ? 'text-amber-500' : 'text-red-500';
            const titleColor = isWarning ? 'text-amber-800' : 'text-red-800';
            const textColor = isWarning ? 'text-amber-700' : 'text-red-700';
            const buttonHoverBg = isWarning ? 'hover:bg-amber-100' : 'hover:bg-red-100';
            const buttonFocusRing = isWarning ? 'focus:ring-amber-600 focus:ring-offset-amber-50' : 'focus:ring-red-600 focus:ring-offset-red-50';


            return (
                 <div className={`flex items-start p-3 mb-3 rounded-md shadow-lg border-l-4 ${bgColor} ${isVisible ? 'notification-slide-in' : 'notification-slide-out'}`}>
                    <div className="flex-shrink-0 pt-0.5">
                        <i className={`fas ${isWarning ? 'fa-triangle-exclamation' : 'fa-calendar-times'} ${iconColor} fa-lg`}></i>
                    </div>
                    <div className="ml-3 flex-1">
                        <p className={`text-sm font-medium ${titleColor}`}>
                            <strong>{notification.title}</strong>
                        </p>
                        <p className={`mt-1 text-xs ${textColor}`}>
                            Прилад типу "{notification.device.type || 'Невідомий тип'}" (РМ: {notification.device.rm || '?'})
                            потребує повірки в "{notification.device.povirkyLocation}". Наступна повірка: {notification.nextCheckDateText}.
                        </p>
                    </div>
                    <div className="ml-auto pl-3">
                        <div className="-mx-1.5 -my-1.5">
                            <button
                                type="button"
                                onClick={handleClose}
                                className={`inline-flex rounded-md p-1.5 ${iconColor} ${buttonHoverBg} focus:outline-none focus:ring-2 ${buttonFocusRing}`}
                            >
                                <span className="sr-only">Закрити</span>
                                <i className="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // NotificationsArea Component
        function NotificationsArea({ devices }) {
            const [notifications, setNotifications] = useState([]);

            useEffect(() => {
                const activeNotifications = devices
                    .map(device => {
                        const nextCheck = calculateNextCheckDate(device.lastCheckDate, device.mpi);
                        const status = getNextCheckDateStatus(nextCheck); // Получаем isWarning, isExpired
                        const hasValidPovirkyLocation = device.povirkyLocation && device.povirkyLocation.trim() !== '-' && device.povirkyLocation.trim() !== '';

                        if (status.isExpired && hasValidPovirkyLocation) {
                            return {
                                id: device.id + '-expired-notif', // Уникальный ID для ключа
                                device,
                                title: 'Прострочена Повірка!',
                                nextCheckDateText: status.text,
                                type: 'expired', // Для стилизации
                                date: status.date // Для сортировки
                            };
                        } else if (status.isWarning && hasValidPovirkyLocation) {
                             return {
                                id: device.id + '-warning-notif', // Уникальный ID
                                device,
                                title: 'Незабаром Повірка!',
                                nextCheckDateText: status.text,
                                type: 'warning', // Для стилизации
                                date: status.date // Для сортировки
                            };
                        }
                        return null;
                    })
                    .filter(Boolean) // Удаляем null значения
                    .sort((a, b) => { // Сортируем: сначала просроченные, потом предупреждения, потом по дате
                        if (a.type === 'expired' && b.type !== 'expired') return -1;
                        if (a.type !== 'expired' && b.type === 'expired') return 1;
                        if (a.type === 'warning' && b.type !== 'warning') return -1;
                        if (a.type !== 'warning' && b.type === 'warning') return 1;
                        return (a.date && b.date) ? a.date.getTime() - b.date.getTime() : 0;
                    });
                
                setNotifications(activeNotifications);
            }, [devices]);

            const handleCloseNotification = (id) => {
                setNotifications(prev => prev.filter(n => n.id !== id));
            };

            if (notifications.length === 0) return null;

            return (
                <div className="my-4 space-y-3">
                    {notifications.map(notif => (
                        <NotificationItem key={notif.id} notification={notif} onClose={() => handleCloseNotification(notif.id)} />
                    ))}
                </div>
            );
        }


        // Main App Component
        function App() {
            const [devices, setDevices] = useState([]);
            const [currentRMFilter, setCurrentRMFilter] = useState('all');
            const [editingDevice, setEditingDevice] = useState(null);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [isLoading, setIsLoading] = useState(true);

            const loadDevices = useCallback(async () => {
                setIsLoading(true);
                try {
                    await initDB(); 
                    let currentDevs = await getAllDevicesDB();
                    if (currentDevs.length === 0) {
                        console.log("База даних порожня. Спроба імпорту з CSV...");
                        try {
                            const response = await fetch('Прилади - Аркуш1.csv'); // Убедитесь, что файл доступен
                            if (!response.ok) throw new Error(`Не вдалося завантажити CSV: ${response.statusText}`);
                            const csvText = await response.text();
                            const parsedDevices = await parseCSV(csvText);
                            
                            if (parsedDevices.length > 0) {
                                const savePromises = parsedDevices.map(devData => {
                                    // Генерируем ID для новых приборов из CSV
                                    const newId = (devData.serial || 'no_serial_csv') + '_' + Date.now() + '_' + Math.random().toString(16).slice(2,8);
                                    const deviceToSave = {
                                      ...devData,
                                      id: newId,
                                      // Рассчитываем nextCheckDate при импорте
                                      nextCheckDate: calculateNextCheckDate(devData.lastCheckDate, devData.mpi) 
                                    };
                                    return saveDeviceDB(deviceToSave);
                                });
                                await Promise.all(savePromises);
                                console.log(`${parsedDevices.length} приладів імпортовано та збережено.`);
                                currentDevs = await getAllDevicesDB(); // Перезагружаем после импорта
                            } else {
                                console.log("CSV файл порожній або не містить валідних даних.");
                            }
                        } catch (csvError) {
                            console.error("Помилка імпорту CSV:", csvError);
                            // Можно показать пользователю неблокирующее уведомление
                        }
                    }
                    setDevices(currentDevs);
                } catch (error) {
                    console.error("Failed to load devices:", error);
                    alert("Помилка завантаження приладів. Перевірте консоль.");
                } finally {
                    setIsLoading(false);
                }
            }, []);

            useEffect(() => {
                loadDevices();
            }, [loadDevices]); // Зависимость loadDevices здесь корректна

            const handleRMFILTERChange = (rm) => setCurrentRMFilter(rm);

            const handleAddDevice = () => {
                setEditingDevice(null); // Для нового прибора
                setIsModalOpen(true);
            };

            const handleEditDevice = (device) => {
                setEditingDevice(device);
                setIsModalOpen(true);
            };

            const handleCloseModal = () => {
                setIsModalOpen(false);
                setEditingDevice(null); // Очищаем редактируемый прибор
            };

            const handleSaveDevice = async (deviceData) => {
                try {
                    let deviceToSave;
                    if (deviceData.id) { // Редактирование существующего
                        deviceToSave = { ...deviceData };
                    } else { // Добавление нового
                        // Генерируем уникальный ID
                        const newId = (deviceData.serial || 'no_serial_new') + '_' + Date.now() + '_' + Math.random().toString(16).slice(2,8);
                        deviceToSave = { ...deviceData, id: newId };
                    }
                    // Пересчитываем дату следующей поверки перед сохранением
                    deviceToSave.nextCheckDate = calculateNextCheckDate(deviceToSave.lastCheckDate, deviceToSave.mpi);

                    await saveDeviceDB(deviceToSave);
                    await loadDevices(); // Перезагружаем список для обновления UI
                    handleCloseModal();
                } catch (error) {
                    console.error("Failed to save device:", error);
                    alert("Помилка збереження приладу. Перевірте консоль.");
                }
            };

            const handleDeleteDevice = async (deviceId) => {
                try {
                    await deleteDeviceDB(deviceId);
                    await loadDevices(); // Перезагружаем список
                    handleCloseModal(); // Закрываем модалку, если она была открыта для этого прибора
                } catch (error) {
                    console.error("Failed to delete device:", error);
                    alert("Помилка видалення приладу. Перевірте консоль.");
                }
            };

            // Расчет количества просроченных приборов
            const overdueCount = useMemo(() => {
                return devices.filter(device => {
                    const nextCheck = calculateNextCheckDate(device.lastCheckDate, device.mpi);
                    const status = getNextCheckDateStatus(nextCheck);
                    return status.isExpired; // Используем флаг isExpired
                }).length;
            }, [devices]);


            return (
                <div className="min-h-screen bg-gray-100">
                    <Header overdueCount={overdueCount} />
                    <main className="container mx-auto p-4 max-w-6xl">
                        <FilterControls
                            currentRM={currentRMFilter}
                            onRMChange={handleRMFILTERChange}
                            onAddDevice={handleAddDevice}
                        />
                        <NotificationsArea devices={devices} /> {/* Передаем все приборы */}
                        {isLoading ? (
                             <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Завантаження приладів...</div>
                        ) : (
                            <DeviceList
                                devices={devices}
                                onEdit={handleEditDevice}
                                currentRMFilter={currentRMFilter}
                            />
                        )}
                    </main>
                    {isModalOpen && (
                        <DeviceModal
                            device={editingDevice}
                            onClose={handleCloseModal}
                            onSave={handleSaveDevice}
                            onDelete={handleDeleteDevice}
                        />
                    )}
                </div>
            );
        }

        // Render the App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            const swPath = 'service-worker.js'; 
            const swScope = './'; 

            console.log(`Registering Service Worker at: ${swPath} with scope: ${swScope}`);
            navigator.serviceWorker.register(swPath, { scope: swScope })
            .then(registration => {
                console.log('Service Worker зареєстровано:', registration.scope);
                registration.onupdatefound = () => {
                    const installingWorker = registration.installing;
                    if (installingWorker) {
                        installingWorker.onstatechange = () => {
                            if (installingWorker.state === 'installed') {
                                if (navigator.serviceWorker.controller) {
                                    console.log('Новий Service Worker встановлено. Оновіть сторінку для застосування.');
                                    // Здесь можно показать UI для обновления
                                } else {
                                    console.log('Контент кешовано для офлайн використання.');
                                }
                            }
                        };
                    }
                };
            })
            .catch(error => {
                console.error('Помилка реєстрації Service Worker:', error);
            });
        } else {
             console.log('Service Worker не підтримується цим браузером.');
        }

    </script>
</body>
</html>
