<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#3a86ff"/>
    <title>Список Приладів (React)</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="img/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f4f8;
            color: #1c3144;
        }
        /* Custom scrollbar for modal content if needed */
        .modal-content-scrollable::-webkit-scrollbar {
            width: 8px;
        }
        .modal-content-scrollable::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
        }
        .modal-content-scrollable::-webkit-scrollbar-track {
            background-color: #e2e8f0;
        }
        /* Simple animation for modal */
        @keyframes fadeInScale {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .modal-animation {
            animation: fadeInScale 0.2s ease-out;
        }
         /* Notification animation */
        @keyframes slideInNotification {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideOutNotification {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }
        .notification-slide-in { animation: slideInNotification 0.3s ease-out forwards; }
        .notification-slide-out { animation: slideOutNotification 0.3s ease-out forwards; }

        .date-expired-bg { background-color: #f8d7da; border-color: #f5c6cb; color: #721c24; }
        .date-warning-bg { background-color: #fff3cd; border-color: #ffeeba; color: #856404; }
        .timeline-expired { background-color: #dc3545; }
        .timeline-warning { background-color: #ffc107; }
        .timeline-ok { background-color: #28a745; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;

        // --- Database Utilities (db.js) ---
        const DB_NAME = 'priboriReactDB';
        const STORE_NAME = 'devices';
        const DB_VERSION = 1;
        let dbInstance = null;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (dbInstance) {
                    resolve(dbInstance);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => reject(`Database error: ${event.target.error}`);
                request.onsuccess = (event) => {
                    dbInstance = event.target.result;
                    dbInstance.onclose = () => { dbInstance = null; console.warn("Database connection closed."); };
                    resolve(dbInstance);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onblocked = () => {
                    console.warn("Database open request blocked.");
                    alert("Будь ласка, закрийте інші вкладки з цим додатком, щоб оновити базу даних.");
                };
            });
        }

        async function getAllDevicesDB() {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onerror = (event) => reject(`Error getting all devices: ${event.target.error}`);
                request.onsuccess = (event) => resolve(event.target.result || []);
            });
        }

        async function saveDeviceDB(device) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                if (!device || typeof device.id === 'undefined') {
                    return reject("Invalid device object: ID is missing.");
                }
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(device);
                request.onerror = (event) => reject(`Error saving device: ${event.target.error}`);
                request.onsuccess = () => resolve();
            });
        }

        async function deleteDeviceDB(deviceId) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                if (!deviceId) return reject("Invalid device ID.");
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(deviceId);
                request.onerror = (event) => reject(`Error deleting device: ${event.target.error}`);
                request.onsuccess = () => resolve();
            });
        }

        // --- Calculation Utilities (calculations.js) ---
        function formatDate(dateString) {
            if (!dateString) return '--.--.----';
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'Невірна дата';
                const day = String(date.getUTCDate()).padStart(2, '0');
                const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                const year = date.getUTCFullYear();
                return `${day}.${month}.${year}`;
            } catch (e) { return 'Помилка дати'; }
        }

        function calculateNextCheckDate(lastCheckDateStr, mpiYears) {
            if (!lastCheckDateStr || !mpiYears || isNaN(parseInt(mpiYears)) || mpiYears <= 0) return null;
            try {
                const lastCheckDate = new Date(lastCheckDateStr);
                if (isNaN(lastCheckDate.getTime())) return null;
                lastCheckDate.setUTCFullYear(lastCheckDate.getUTCFullYear() + parseInt(mpiYears));
                lastCheckDate.setUTCDate(lastCheckDate.getUTCDate() - 1); // As per original logic (day before anniversary)
                return lastCheckDate.toISOString().split('T')[0];
            } catch (e) { return null; }
        }

        function getNextCheckDateStatus(nextCheckDateStr) {
            if (!nextCheckDateStr) return { text: 'Не вказано', className: '', date: null, sortPriority: 0 };
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);
            try {
                const nextCheckDate = new Date(nextCheckDateStr);
                if (isNaN(nextCheckDate.getTime())) return { text: 'Невірна дата', className: '', date: null, sortPriority: 0 };
                nextCheckDate.setUTCHours(0, 0, 0, 0);
                
                const warningDate = new Date(nextCheckDate);
                warningDate.setUTCDate(warningDate.getUTCDate() - 30); // 30 day warning period
                
                const formattedDate = formatDate(nextCheckDateStr);

                if (nextCheckDate < today) {
                    return { text: formattedDate, className: 'date-expired-bg', date: nextCheckDate, sortPriority: 3 };
                } else if (warningDate <= today) {
                    return { text: formattedDate, className: 'date-warning-bg', date: nextCheckDate, sortPriority: 2 };
                } else {
                    return { text: formattedDate, className: 'text-gray-700', date: nextCheckDate, sortPriority: 1 };
                }
            } catch (e) { return { text: 'Помилка дати', className: '', date: null, sortPriority: 0 }; }
        }

        function getTimelineData(lastCheckDateStr, nextCheckDateStr, mpiYears) {
            const statusInfo = getNextCheckDateStatus(nextCheckDateStr);
            let timelineClassName = 'timeline-ok';
            if (statusInfo.className.includes('expired')) timelineClassName = 'timeline-expired';
            else if (statusInfo.className.includes('warning')) timelineClassName = 'timeline-warning';

            if (!lastCheckDateStr || !nextCheckDateStr || !mpiYears || mpiYears <= 0) {
                return { percent: 0, timelineClassName };
            }
            try {
                const lastCheckDate = new Date(lastCheckDateStr);
                const nextCheckDate = new Date(nextCheckDateStr); // This is already "day before"
                const today = new Date();
                today.setUTCHours(0, 0, 0, 0);
                lastCheckDate.setUTCHours(0, 0, 0, 0);
                // nextCheckDate is already correctly set (day before anniversary) for total duration calculation
                // For actual end of period, add 1 day to nextCheckDate
                const periodEndDate = new Date(nextCheckDate);
                periodEndDate.setUTCDate(periodEndDate.getUTCDate() + 1);


                if (isNaN(lastCheckDate.getTime()) || isNaN(periodEndDate.getTime())) {
                    return { percent: 0, timelineClassName };
                }

                const totalDuration = periodEndDate.getTime() - lastCheckDate.getTime();
                const timeElapsed = today.getTime() - lastCheckDate.getTime();
                
                let percentElapsed = 0;
                if (totalDuration > 0) {
                    percentElapsed = (timeElapsed / totalDuration) * 100;
                    percentElapsed = Math.max(0, Math.min(100, percentElapsed));
                } else if (timeElapsed >= 0) { // If total duration is zero or negative (e.g. last check is today or in future)
                    percentElapsed = (today >= lastCheckDate) ? 100 : 0;
                }
                
                if (statusInfo.className.includes('expired')) {
                    percentElapsed = 100;
                }

                return { percent: Math.round(percentElapsed), timelineClassName };
            } catch (e) {
                console.error("Error in getTimelineData", e);
                return { percent: 0, timelineClassName };
            }
        }

        // --- CSV Parser Utility (csvParser.js) ---
        async function parseCSV(csvText) {
            const lines = csvText.split(/\r?\n/);
            const devicesToImport = [];
            // Start from 3rd line (index 2) as per original logic
            for (let i = 2; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const columns = line.split(',');
                if (columns.length < 9) continue; // Basic check

                const rm = columns[1]?.trim();
                const name = columns[2]?.trim();
                const type = columns[3]?.trim();
                const serial = columns[4]?.trim();
                const lastCheckDateStr = columns[5]?.trim();
                const mpiStr = columns[7]?.trim();
                const location = columns[8]?.trim();

                if (!rm || !name || !type || !serial) continue;

                let lastCheckDate = null;
                const dateMatch = lastCheckDateStr.match(/^(\d{2})\.(\d{2})\.(\d{4})$/);
                if (dateMatch) {
                    lastCheckDate = `${dateMatch[3]}-${dateMatch[2]}-${dateMatch[1]}`;
                }
                const mpi = parseInt(mpiStr) || null;

                devicesToImport.push({
                    // ID will be generated later
                    rm, name, type, serial, lastCheckDate, mpi, location: location || null,
                    povirkyLocation: null, notes: null,
                });
            }
            return devicesToImport;
        }


        // --- React Components ---

        // Header Component
        function Header({ overdueCount }) {
            return (
                <header className="bg-gradient-to-r from-blue-600 to-blue-500 text-white p-4 shadow-md sticky top-0 z-50">
                    <div className="container mx-auto flex justify-between items-center max-w-6xl">
                        <h1 className="text-xl sm:text-2xl font-semibold">Список приладів</h1>
                        <div title="Кількість приладів з простроченою повіркою" className="flex items-center gap-2 bg-white/20 px-3 py-1.5 rounded-md text-sm font-medium">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" className="bi bi-exclamation-triangle-fill text-yellow-300" viewBox="0 0 16 16">
                                <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5m.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2"/>
                            </svg>
                            <span>{overdueCount}</span>
                        </div>
                    </div>
                </header>
            );
        }

        // FilterControls Component
        function FilterControls({ currentRM, onRMChange, onAddDevice }) {
            const rms = ["all", "111", "112"];
            return (
                <div className="my-4 flex flex-wrap gap-4 items-center justify-between">
                    <div className="flex items-center gap-2">
                        <span className="text-sm font-medium text-gray-600">РМ:</span>
                        <div className="inline-flex rounded-md shadow-sm bg-gray-200">
                            {rms.map(rm => (
                                <button
                                    key={rm}
                                    onClick={() => onRMChange(rm)}
                                    className={`px-3 py-1.5 text-sm font-medium first:rounded-l-md last:rounded-r-md border border-gray-300 focus:z-10 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors
                                        ${currentRM === rm ? 'bg-blue-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}`}
                                >
                                    {rm === "all" ? "Всі" : rm}
                                </button>
                            ))}
                        </div>
                    </div>
                    <button
                        onClick={onAddDevice}
                        className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:shadow-lg transition-all duration-150 ease-in-out flex items-center gap-2 text-sm"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" className="bi bi-plus-lg" viewBox="0 0 16 16">
                            <path fillRule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2"/>
                        </svg>
                        Додати
                    </button>
                </div>
            );
        }

        // DeviceCard Component
        function DeviceCard({ device, onEdit }) {
            const nextCheckStatus = getNextCheckDateStatus(calculateNextCheckDate(device.lastCheckDate, device.mpi));
            const timeline = getTimelineData(device.lastCheckDate, calculateNextCheckDate(device.lastCheckDate, device.mpi), device.mpi);

            return (
                <div
                    onClick={() => onEdit(device)}
                    className="bg-white rounded-lg shadow-lg hover:shadow-xl transition-shadow duration-200 p-4 cursor-pointer border border-gray-200"
                >
                    <h3 className="text-md font-semibold text-blue-700 mb-1 truncate">{device.name || 'Без назви'}</h3>
                    <p className="text-xs text-blue-500 font-medium mb-2">{device.type || '-'}</p>
                    <div className="space-y-1 text-xs text-gray-600">
                        <p><strong>Зав. №:</strong> {device.serial || '-'}</p>
                        <p><strong>РМ:</strong> {device.rm || '-'}</p>
                        <p><strong>Розташування:</strong> {device.location || '-'}</p>
                        <p><strong>Місце повірки:</strong> {device.povirkyLocation || '-'}</p>
                        <p><strong>Остання пов.:</strong> {formatDate(device.lastCheckDate)}</p>
                        <p><strong>МПІ:</strong> {device.mpi ? `${device.mpi} р.` : '-'}</p>
                        <p className="flex items-center"><strong>Наступна пов.:</strong>
                            <span className={`ml-1 px-1.5 py-0.5 rounded-sm text-xs font-medium ${nextCheckStatus.className}`}>
                                {nextCheckStatus.text}
                            </span>
                        </p>
                    </div>
                    {(timeline.percent > 0 || timeline.timelineClassName === 'timeline-expired') && (
                        <div className="mt-3" title={`Минуло приблизно ${timeline.percent}% інтервалу повірки`}>
                            <div className="w-full bg-gray-200 rounded-full h-1.5">
                                <div
                                    className={`h-1.5 rounded-full ${timeline.timelineClassName} transition-all duration-500 ease-out`}
                                    style={{ width: `${timeline.percent}%` }}
                                ></div>
                            </div>
                        </div>
                    )}
                    {device.notes && <p className="mt-2 text-xs text-gray-500 italic border-t border-gray-100 pt-1"><strong>Примітки:</strong> {device.notes}</p>}
                </div>
            );
        }

        // DeviceList Component
        function DeviceList({ devices, onEdit, currentRMFilter }) {
             const filteredDevices = useMemo(() => {
                const filtered = currentRMFilter === 'all'
                    ? [...devices]
                    : devices.filter(device => device.rm === currentRMFilter);

                return filtered.sort((a, b) => {
                    const statusA = getNextCheckDateStatus(calculateNextCheckDate(a.lastCheckDate, a.mpi));
                    const statusB = getNextCheckDateStatus(calculateNextCheckDate(b.lastCheckDate, b.mpi));

                    if (statusB.sortPriority !== statusA.sortPriority) {
                        return statusB.sortPriority - statusA.sortPriority;
                    }
                    const dateA = statusA.date;
                    const dateB = statusB.date;
                    if (dateA && dateB) return dateA.getTime() - dateB.getTime();
                    if (dateA) return -1;
                    if (dateB) return 1;
                    return 0;
                });
            }, [devices, currentRMFilter]);


            if (devices.length === 0) {
                return <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Завантаження приладів або список порожній...</div>;
            }
            if (filteredDevices.length === 0 && currentRMFilter !== 'all') {
                 return <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Немає приладів для РМ "{currentRMFilter}".</div>;
            }


            return (
                <>
                    <div className="text-sm text-gray-600 text-right mb-2">
                        Показано: {filteredDevices.length} прилад(ів)
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                        {filteredDevices.map(device => (
                            <DeviceCard key={device.id} device={device} onEdit={onEdit} />
                        ))}
                    </div>
                </>
            );
        }

        // DeviceModal Component
        function DeviceModal({ device, onClose, onSave, onDelete }) {
            const [formData, setFormData] = useState({
                id: '', rm: '', name: '', type: '', serial: '',
                lastCheckDate: '', mpi: '', location: '', povirkyLocation: '', notes: ''
            });

            useEffect(() => {
                if (device) {
                    setFormData({ ...device, mpi: device.mpi || '' }); // Ensure mpi is string for input
                } else {
                    setFormData({
                        id: '', rm: '', name: '', type: '', serial: '',
                        lastCheckDate: '', mpi: '', location: '', povirkyLocation: '', notes: ''
                    });
                }
            }, [device]);

            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                const deviceToSave = {
                    ...formData,
                    mpi: formData.mpi ? parseInt(formData.mpi) : null,
                    lastCheckDate: formData.lastCheckDate || null,
                };
                if (!deviceToSave.rm || !deviceToSave.name || !deviceToSave.type || !deviceToSave.serial) {
                    alert("Будь ласка, заповніть обов'язкові поля: РМ, Найменування, Тип, Заводський номер.");
                    return;
                }
                onSave(deviceToSave);
            };

            const handleDelete = () => {
                if (device && device.id && window.confirm(`Ви впевнені, що хочете видалити "${device.name || 'цей прилад'}"?`)) {
                    onDelete(device.id);
                }
            };
            
            const inputClass = "mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm";
            const labelClass = "block text-sm font-medium text-gray-700";

            return (
                <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center p-4 z-[1000] modal-animation" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg max-h-[90vh] overflow-y-auto modal-content-scrollable" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-semibold text-gray-800">{device ? 'Редагувати Прилад' : 'Додати Прилад'}</h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                                </svg>
                            </button>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label htmlFor="device-rm" className={labelClass}>РМ: <span className="text-red-500">*</span></label>
                                <input type="text" name="rm" id="device-rm" value={formData.rm} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-name" className={labelClass}>Найменування: <span className="text-red-500">*</span></label>
                                <input type="text" name="name" id="device-name" value={formData.name} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-type" className={labelClass}>Тип: <span className="text-red-500">*</span></label>
                                <input type="text" name="type" id="device-type" value={formData.type} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-serial" className={labelClass}>Заводський номер: <span className="text-red-500">*</span></label>
                                <input type="text" name="serial" id="device-serial" value={formData.serial} onChange={handleChange} className={inputClass} required />
                            </div>
                            <div>
                                <label htmlFor="device-lastCheckDate" className={labelClass}>Дата останньої повірки:</label>
                                <input type="date" name="lastCheckDate" id="device-lastCheckDate" value={formData.lastCheckDate} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-mpi" className={labelClass}>МПІ (роки):</label>
                                <input type="number" name="mpi" id="device-mpi" value={formData.mpi} onChange={handleChange} className={inputClass} min="1" />
                            </div>
                            <div>
                                <label htmlFor="device-location" className={labelClass}>Де прилад:</label>
                                <input type="text" name="location" id="device-location" value={formData.location} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-povirkyLocation" className={labelClass}>Місце повірки:</label>
                                <input type="text" name="povirkyLocation" id="device-povirkyLocation" value={formData.povirkyLocation} onChange={handleChange} className={inputClass} />
                            </div>
                            <div>
                                <label htmlFor="device-notes" className={labelClass}>Примітки:</label>
                                <textarea name="notes" id="device-notes" value={formData.notes} onChange={handleChange} rows="3" className={inputClass}></textarea>
                            </div>
                            <div className="flex justify-between items-center pt-4 border-t border-gray-200 mt-6">
                                <button type="submit" className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:shadow-md transition flex items-center gap-2">
                                    <i className="fas fa-save"></i> Зберегти
                                </button>
                                {device && (
                                    <button type="button" onClick={handleDelete} className="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:shadow-md transition flex items-center gap-2">
                                        <i className="fas fa-trash"></i> Видалити
                                    </button>
                                )}
                            </div>
                        </form>
                    </div>
                </div>
            );
        }
        
        // NotificationItem Component
        function NotificationItem({ notification, onClose }) {
            const [isVisible, setIsVisible] = useState(true);

            const handleClose = () => {
                setIsVisible(false);
                // Call onClose after animation
                setTimeout(onClose, 300);
            };
            
            if (!notification.device) return null;

            return (
                 <div className={`flex items-start p-3 mb-3 rounded-md shadow-lg border-l-4 ${notification.type === 'warning' ? 'bg-yellow-50 border-yellow-400' : 'bg-red-50 border-red-400'} ${isVisible ? 'notification-slide-in' : 'notification-slide-out'}`}>
                    <div className="flex-shrink-0 pt-0.5">
                        {notification.type === 'warning' ? (
                            <i className="fas fa-triangle-exclamation text-yellow-500 fa-lg"></i>
                        ) : (
                            <i className="fas fa-calendar-times text-red-500 fa-lg"></i>
                        )}
                    </div>
                    <div className="ml-3 flex-1">
                        <p className={`text-sm font-medium ${notification.type === 'warning' ? 'text-yellow-800' : 'text-red-800'}`}>
                            <strong>{notification.title}</strong>
                        </p>
                        <p className={`mt-1 text-xs ${notification.type === 'warning' ? 'text-yellow-700' : 'text-red-700'}`}>
                            Прилад типу "{notification.device.type || 'Невідомий тип'}" (РМ: {notification.device.rm || '?'})
                            потребує повірки в "{notification.device.povirkyLocation}". Наступна повірка: {notification.nextCheckDateText}.
                        </p>
                    </div>
                    <div className="ml-auto pl-3">
                        <div className="-mx-1.5 -my-1.5">
                            <button
                                type="button"
                                onClick={handleClose}
                                className={`inline-flex rounded-md p-1.5 focus:outline-none focus:ring-2 ${notification.type === 'warning' ? 'text-yellow-500 hover:bg-yellow-100 focus:ring-yellow-600 focus:ring-offset-2 focus:ring-offset-yellow-50' : 'text-red-500 hover:bg-red-100 focus:ring-red-600 focus:ring-offset-2 focus:ring-offset-red-50'}`}
                            >
                                <span className="sr-only">Закрити</span>
                                <i className="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // NotificationsArea Component
        function NotificationsArea({ devices }) {
            const [notifications, setNotifications] = useState([]);

            useEffect(() => {
                const activeNotifications = devices
                    .map(device => {
                        const nextCheck = calculateNextCheckDate(device.lastCheckDate, device.mpi);
                        const status = getNextCheckDateStatus(nextCheck);
                        const hasValidPovirkyLocation = device.povirkyLocation && device.povirkyLocation.trim() !== '-' && device.povirkyLocation.trim() !== '';

                        if (status.className.includes('expired') && hasValidPovirkyLocation) {
                            return {
                                id: device.id + '-expired',
                                device,
                                title: 'Прострочена Повірка!',
                                nextCheckDateText: status.text,
                                type: 'expired',
                                date: status.date
                            };
                        }
                        // Add warning notifications if needed, similar to original logic
                        // For now, focusing on expired as per original notification display
                        return null;
                    })
                    .filter(Boolean)
                    .sort((a, b) => (a.date && b.date ? a.date.getTime() - b.date.getTime() : 0));
                
                setNotifications(activeNotifications);
            }, [devices]);

            const handleCloseNotification = (id) => {
                setNotifications(prev => prev.filter(n => n.id !== id));
            };

            if (notifications.length === 0) return null;

            return (
                <div className="my-4 space-y-3">
                    {notifications.map(notif => (
                        <NotificationItem key={notif.id} notification={notif} onClose={() => handleCloseNotification(notif.id)} />
                    ))}
                </div>
            );
        }


        // Main App Component
        function App() {
            const [devices, setDevices] = useState([]);
            const [currentRMFilter, setCurrentRMFilter] = useState('all');
            const [editingDevice, setEditingDevice] = useState(null);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [isLoading, setIsLoading] = useState(true);

            const loadDevices = useCallback(async () => {
                setIsLoading(true);
                try {
                    await initDB(); // Ensure DB is initialized
                    let currentDevs = await getAllDevicesDB();
                    if (currentDevs.length === 0) {
                        console.log("База даних порожня. Спроба імпорту з CSV...");
                        try {
                            // Make sure 'Прилади - Аркуш1.csv' is in the same directory as index.html or provide correct path
                            const response = await fetch('Прилади - Аркуш1.csv');
                            if (!response.ok) throw new Error(`Не вдалося завантажити CSV: ${response.statusText}`);
                            const csvText = await response.text();
                            const parsedDevices = await parseCSV(csvText);
                            
                            if (parsedDevices.length > 0) {
                                const savePromises = parsedDevices.map(devData => {
                                    const newId = (devData.serial || 'no_serial') + '_' + Date.now() + '_' + Math.random().toString(16).slice(2,8);
                                    const deviceToSave = {
                                      ...devData,
                                      id: newId,
                                      nextCheckDate: calculateNextCheckDate(devData.lastCheckDate, devData.mpi)
                                    };
                                    return saveDeviceDB(deviceToSave);
                                });
                                await Promise.all(savePromises);
                                console.log(`${parsedDevices.length} приладів імпортовано та збережено.`);
                                currentDevs = await getAllDevicesDB(); // Reload after import
                            } else {
                                console.log("CSV файл порожній або не містить валідних даних.");
                            }
                        } catch (csvError) {
                            console.error("Помилка імпорту CSV:", csvError);
                            // alert("Помилка імпорту даних з CSV. Дивіться консоль.");
                        }
                    }
                    setDevices(currentDevs);
                } catch (error) {
                    console.error("Failed to load devices:", error);
                    alert("Помилка завантаження приладів.");
                } finally {
                    setIsLoading(false);
                }
            }, []);

            useEffect(() => {
                loadDevices();
            }, [loadDevices]);

            const handleRMFILTERChange = (rm) => setCurrentRMFilter(rm);

            const handleAddDevice = () => {
                setEditingDevice(null);
                setIsModalOpen(true);
            };

            const handleEditDevice = (device) => {
                setEditingDevice(device);
                setIsModalOpen(true);
            };

            const handleCloseModal = () => {
                setIsModalOpen(false);
                setEditingDevice(null);
            };

            const handleSaveDevice = async (deviceData) => {
                try {
                    let deviceToSave;
                    if (deviceData.id) { // Editing existing device
                        deviceToSave = { ...deviceData };
                    } else { // Adding new device
                        const newId = (deviceData.serial || 'no_serial') + '_' + Date.now() + '_' + Math.random().toString(16).slice(2,8);
                        // Ensure ID is unique (highly likely with Math.random but good practice)
                        // while (devices.some(d => d.id === newId)) {
                        //    newId = ... (generate again)
                        // }
                        deviceToSave = { ...deviceData, id: newId };
                    }
                    // Recalculate nextCheckDate before saving
                    deviceToSave.nextCheckDate = calculateNextCheckDate(deviceToSave.lastCheckDate, deviceToSave.mpi);

                    await saveDeviceDB(deviceToSave);
                    await loadDevices(); // Reload all devices to reflect changes
                    handleCloseModal();
                } catch (error) {
                    console.error("Failed to save device:", error);
                    alert("Помилка збереження приладу.");
                }
            };

            const handleDeleteDevice = async (deviceId) => {
                try {
                    await deleteDeviceDB(deviceId);
                    await loadDevices(); // Reload all devices
                    handleCloseModal();
                } catch (error) {
                    console.error("Failed to delete device:", error);
                    alert("Помилка видалення приладу.");
                }
            };

            const overdueCount = useMemo(() => {
                return devices.filter(device => {
                    const nextCheck = calculateNextCheckDate(device.lastCheckDate, device.mpi);
                    const status = getNextCheckDateStatus(nextCheck);
                    return status.className.includes('expired');
                }).length;
            }, [devices]);


            return (
                <div className="min-h-screen bg-gray-100">
                    <Header overdueCount={overdueCount} />
                    <main className="container mx-auto p-4 max-w-6xl">
                        <FilterControls
                            currentRM={currentRMFilter}
                            onRMChange={handleRMFILTERChange}
                            onAddDevice={handleAddDevice}
                        />
                        <NotificationsArea devices={devices} />
                        {isLoading ? (
                             <div className="text-center py-10 text-gray-500 bg-white rounded-lg shadow p-6">Завантаження приладів...</div>
                        ) : (
                            <DeviceList
                                devices={devices}
                                onEdit={handleEditDevice}
                                currentRMFilter={currentRMFilter}
                            />
                        )}
                    </main>
                    {isModalOpen && (
                        <DeviceModal
                            device={editingDevice}
                            onClose={handleCloseModal}
                            onSave={handleSaveDevice}
                            onDelete={handleDeleteDevice}
                        />
                    )}
                </div>
            );
        }

        // Render the App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

        // Service Worker Registration (from original index.html)
        if ('serviceWorker' in navigator) {
            const swPath = 'service-worker.js'; // Relative path
            const swScope = './'; // Relative scope for GitHub Pages

            console.log(`Registering Service Worker at: ${swPath} with scope: ${swScope}`);
            navigator.serviceWorker.register(swPath, { scope: swScope })
            .then(registration => {
                console.log('Service Worker зареєстровано:', registration.scope);
                registration.onupdatefound = () => {
                    const installingWorker = registration.installing;
                    if (installingWorker) {
                        installingWorker.onstatechange = () => {
                            if (installingWorker.state === 'installed') {
                                if (navigator.serviceWorker.controller) {
                                    console.log('Новий Service Worker встановлено. Оновіть сторінку для застосування.');
                                    // You can show an "Update available" UI notification here
                                } else {
                                    console.log('Контент кешовано для офлайн використання.');
                                }
                            }
                        };
                    }
                };
            })
            .catch(error => {
                console.error('Помилка реєстрації Service Worker:', error);
            });
        } else {
             console.log('Service Worker не підтримується цим браузером.');
        }

    </script>
</body>
</html>
